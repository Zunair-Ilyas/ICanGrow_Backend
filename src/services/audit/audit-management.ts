import { SupabaseClient } from "@supabase/supabase-js";
import { Database } from "@/types/database.types";
import { getSupabaseAdmin } from "@/services/supabase";

type Audit = Database["public"]["Tables"]["audits"]["Row"];
type AuditInsert = Database["public"]["Tables"]["audits"]["Insert"];
type AuditUpdate = Database["public"]["Tables"]["audits"]["Update"];
type AuditFinding = Database["public"]["Tables"]["audit_findings"]["Row"];
type AuditFindingInsert =
	Database["public"]["Tables"]["audit_findings"]["Insert"];
type AuditFindingUpdate =
	Database["public"]["Tables"]["audit_findings"]["Update"];
type SupplierAudit = Database["public"]["Tables"]["supplier_audits"]["Row"];
type SupplierAuditInsert =
	Database["public"]["Tables"]["supplier_audits"]["Insert"];
type SupplierAuditUpdate =
	Database["public"]["Tables"]["supplier_audits"]["Update"];

export interface AuditWithDetails extends Audit {
	findings?: AuditFinding[];
}

export interface AuditFindingWithDetails extends AuditFinding {
	// Additional fields can be added here if needed
}

export interface SupplierAuditWithDetails extends SupplierAudit {
	// Additional fields can be added here if needed
}

export class AuditManagementService {
	private get supabase() {
		return getSupabaseAdmin();
	}

	// ==================== INTERNAL AUDITS ====================

	async listAudits(
		filters: {
			page?: number;
			limit?: number;
			status?: string;
			type?: string;
			auditor?: string;
			batch_id?: string;
			cycle_id?: string;
			date_from?: string;
			date_to?: string;
		} = {}
	): Promise<{
		audits: AuditWithDetails[];
		total: number;
		page: number;
		limit: number;
	}> {
		try {
			const {
				page = 1,
				limit = 10,
				status,
				type,
				auditor,
				batch_id,
				cycle_id,
				date_from,
				date_to,
			} = filters;

			let query = this.supabase
				.from("audits")
				.select("*", { count: "exact" })
				.order("created_at", { ascending: false });

			// Apply filters
			if (status) {
				query = query.eq("status", status);
			}
			if (type) {
				query = query.eq("type", type);
			}
			if (auditor) {
				query = query.ilike("auditor", `%${auditor}%`);
			}
			if (batch_id) {
				query = query.eq("batch_id", batch_id);
			}
			if (cycle_id) {
				query = query.eq("cycle_id", cycle_id);
			}
			if (date_from) {
				query = query.gte("scheduled_date", date_from);
			}
			if (date_to) {
				query = query.lte("scheduled_date", date_to);
			}

			const {
				data: audits,
				error,
				count,
			} = await query.range((page - 1) * limit, page * limit - 1);

			if (error) {
				throw new Error(`Failed to fetch audits: ${error.message}`);
			}

			return {
				audits: audits || [],
				total: count || 0,
				page,
				limit,
			};
		} catch (error) {
			throw new Error(
				`Failed to list audits: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async getAuditById(auditId: string): Promise<AuditWithDetails> {
		try {
			const { data: audit, error } = await this.supabase
				.from("audits")
				.select("*")
				.eq("id", auditId)
				.single();

			if (error) {
				if (error.code === "PGRST116") {
					throw new Error("Audit not found");
				}
				throw new Error(`Failed to fetch audit: ${error.message}`);
			}

			// Get audit findings
			const { data: findings, error: findingsError } = await this.supabase
				.from("audit_findings")
				.select("*")
				.eq("audit_id", auditId)
				.order("created_at", { ascending: false });

			if (findingsError) {
				console.warn("Failed to fetch audit findings:", findingsError.message);
			}

			return {
				...audit,
				findings: findings || [],
			};
		} catch (error) {
			throw new Error(
				`Failed to get audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async createAudit(
		auditData: Omit<
			AuditInsert,
			"id" | "created_at" | "updated_at" | "audit_number"
		>
	): Promise<Audit> {
		try {
			// Remove audit_number from the data as it will be auto-generated by trigger
			const { audit_number, ...insertData } = auditData as any;

			const { data: audit, error } = await this.supabase
				.from("audits")
				.insert(insertData)
				.select()
				.single();

			if (error) {
				throw new Error(`Failed to create audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to create audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async updateAudit(auditId: string, auditData: AuditUpdate): Promise<Audit> {
		try {
			const { data: audit, error } = await this.supabase
				.from("audits")
				.update(auditData)
				.eq("id", auditId)
				.select()
				.single();

			if (error) {
				if (error.code === "PGRST116") {
					throw new Error("Audit not found");
				}
				throw new Error(`Failed to update audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to update audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async deleteAudit(auditId: string): Promise<void> {
		try {
			const { error } = await this.supabase
				.from("audits")
				.delete()
				.eq("id", auditId);

			if (error) {
				throw new Error(`Failed to delete audit: ${error.message}`);
			}
		} catch (error) {
			throw new Error(
				`Failed to delete audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async startAudit(auditId: string): Promise<Audit> {
		try {
			const { data: audit, error } = await this.supabase
				.from("audits")
				.update({ status: "in_progress" })
				.eq("id", auditId)
				.select()
				.single();

			if (error) {
				throw new Error(`Failed to start audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to start audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async completeAudit(auditId: string, completedDate?: string): Promise<Audit> {
		try {
			const { data: audit, error } = await this.supabase
				.from("audits")
				.update({
					status: "completed",
					completed_date:
						completedDate || new Date().toISOString().split("T")[0],
				})
				.eq("id", auditId)
				.select()
				.single();

			if (error) {
				throw new Error(`Failed to complete audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to complete audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async cancelAudit(auditId: string, reason?: string): Promise<Audit> {
		try {
			// First get the current audit to access existing notes
			const { data: currentAudit, error: fetchError } = await this.supabase
				.from("audits")
				.select("notes")
				.eq("id", auditId)
				.single();

			if (fetchError) {
				throw new Error(`Failed to fetch audit: ${fetchError.message}`);
			}

			const { data: audit, error } = await this.supabase
				.from("audits")
				.update({
					status: "cancelled",
					notes: reason
						? `${
								currentAudit?.notes || ""
						  }\n\nCancellation reason: ${reason}`.trim()
						: currentAudit?.notes,
				})
				.eq("id", auditId)
				.select()
				.single();

			if (error) {
				throw new Error(`Failed to cancel audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to cancel audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	// ==================== AUDIT FINDINGS ====================

	async getAuditFindings(auditId: string): Promise<AuditFindingWithDetails[]> {
		try {
			const { data: findings, error } = await this.supabase
				.from("audit_findings")
				.select("*")
				.eq("audit_id", auditId)
				.order("created_at", { ascending: false });

			if (error) {
				throw new Error(`Failed to fetch audit findings: ${error.message}`);
			}

			return findings || [];
		} catch (error) {
			throw new Error(
				`Failed to get audit findings: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async addAuditFinding(
		findingData: Omit<AuditFindingInsert, "id" | "created_at" | "updated_at">
	): Promise<AuditFinding> {
		try {
			const { data: finding, error } = await this.supabase
				.from("audit_findings")
				.insert(findingData)
				.select()
				.single();

			if (error) {
				throw new Error(`Failed to add audit finding: ${error.message}`);
			}

			return finding;
		} catch (error) {
			throw new Error(
				`Failed to add audit finding: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async updateAuditFinding(
		findingId: string,
		findingData: AuditFindingUpdate
	): Promise<AuditFinding> {
		try {
			const { data: finding, error } = await this.supabase
				.from("audit_findings")
				.update(findingData)
				.eq("id", findingId)
				.select()
				.single();

			if (error) {
				if (error.code === "PGRST116") {
					throw new Error("Audit finding not found");
				}
				throw new Error(`Failed to update audit finding: ${error.message}`);
			}

			return finding;
		} catch (error) {
			throw new Error(
				`Failed to update audit finding: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async deleteAuditFinding(findingId: string): Promise<void> {
		try {
			const { error } = await this.supabase
				.from("audit_findings")
				.delete()
				.eq("id", findingId);

			if (error) {
				throw new Error(`Failed to delete audit finding: ${error.message}`);
			}
		} catch (error) {
			throw new Error(
				`Failed to delete audit finding: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	// ==================== SUPPLIER AUDITS ====================

	async listSupplierAudits(
		filters: {
			page?: number;
			limit?: number;
			status?: string;
			audit_type?: string;
			supplier_id?: string;
			date_from?: string;
			date_to?: string;
		} = {}
	): Promise<{
		audits: SupplierAuditWithDetails[];
		total: number;
		page: number;
		limit: number;
	}> {
		try {
			const {
				page = 1,
				limit = 10,
				status,
				audit_type,
				supplier_id,
				date_from,
				date_to,
			} = filters;

			let query = this.supabase
				.from("supplier_audits")
				.select("*", { count: "exact" })
				.order("created_at", { ascending: false });

			// Apply filters
			if (status) {
				query = query.eq("status", status);
			}
			if (audit_type) {
				query = query.eq("audit_type", audit_type);
			}
			if (supplier_id) {
				query = query.eq("supplier_id", supplier_id);
			}
			if (date_from) {
				query = query.gte("audit_date", date_from);
			}
			if (date_to) {
				query = query.lte("audit_date", date_to);
			}

			const {
				data: audits,
				error,
				count,
			} = await query.range((page - 1) * limit, page * limit - 1);

			if (error) {
				throw new Error(`Failed to fetch supplier audits: ${error.message}`);
			}

			return {
				audits: audits || [],
				total: count || 0,
				page,
				limit,
			};
		} catch (error) {
			throw new Error(
				`Failed to list supplier audits: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async getSupplierAuditById(
		auditId: string
	): Promise<SupplierAuditWithDetails> {
		try {
			const { data: audit, error } = await this.supabase
				.from("supplier_audits")
				.select("*")
				.eq("id", auditId)
				.single();

			if (error) {
				if (error.code === "PGRST116") {
					throw new Error("Supplier audit not found");
				}
				throw new Error(`Failed to fetch supplier audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to get supplier audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async createSupplierAudit(
		auditData: Omit<
			SupplierAuditInsert,
			"id" | "created_at" | "updated_at" | "audit_number"
		>
	): Promise<SupplierAudit> {
		try {
			// Remove audit_number from the data as it will be auto-generated by trigger
			const { audit_number, ...insertData } = auditData as any;

			const { data: audit, error } = await this.supabase
				.from("supplier_audits")
				.insert(insertData)
				.select()
				.single();

			if (error) {
				throw new Error(`Failed to create supplier audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to create supplier audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async updateSupplierAudit(
		auditId: string,
		auditData: SupplierAuditUpdate
	): Promise<SupplierAudit> {
		try {
			const { data: audit, error } = await this.supabase
				.from("supplier_audits")
				.update(auditData)
				.eq("id", auditId)
				.select()
				.single();

			if (error) {
				if (error.code === "PGRST116") {
					throw new Error("Supplier audit not found");
				}
				throw new Error(`Failed to update supplier audit: ${error.message}`);
			}

			return audit;
		} catch (error) {
			throw new Error(
				`Failed to update supplier audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	async deleteSupplierAudit(auditId: string): Promise<void> {
		try {
			const { error } = await this.supabase
				.from("supplier_audits")
				.delete()
				.eq("id", auditId);

			if (error) {
				throw new Error(`Failed to delete supplier audit: ${error.message}`);
			}
		} catch (error) {
			throw new Error(
				`Failed to delete supplier audit: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}

	// ==================== AUDIT REPORTS ====================

	async getAuditSummary(): Promise<{
		total_audits: number;
		scheduled_audits: number;
		in_progress_audits: number;
		completed_audits: number;
		cancelled_audits: number;
		total_findings: number;
		open_findings: number;
		critical_findings: number;
	}> {
		try {
			// Get audit counts by status
			const { data: auditStats, error: auditError } = await this.supabase
				.from("audits")
				.select("status, findings_count, open_findings")
				.not("status", "is", null);

			if (auditError) {
				throw new Error(
					`Failed to fetch audit statistics: ${auditError.message}`
				);
			}

			// Get critical findings count
			const { data: criticalFindings, error: findingsError } =
				await this.supabase
					.from("audit_findings")
					.select("id")
					.eq("finding_type", "critical");

			if (findingsError) {
				console.warn(
					"Failed to fetch critical findings:",
					findingsError.message
				);
			}

			const stats = auditStats?.reduce(
				(acc: any, audit: any) => {
					acc.total_audits++;
					const statusKey = `${audit.status}_audits` as keyof typeof acc;
					if (statusKey in acc) {
						(acc[statusKey] as number)++;
					}
					acc.total_findings += audit.findings_count || 0;
					acc.open_findings += audit.open_findings || 0;
					return acc;
				},
				{
					total_audits: 0,
					scheduled_audits: 0,
					in_progress_audits: 0,
					completed_audits: 0,
					cancelled_audits: 0,
					total_findings: 0,
					open_findings: 0,
					critical_findings: criticalFindings?.length || 0,
				}
			);

			return (
				stats || {
					total_audits: 0,
					scheduled_audits: 0,
					in_progress_audits: 0,
					completed_audits: 0,
					cancelled_audits: 0,
					total_findings: 0,
					open_findings: 0,
					critical_findings: 0,
				}
			);
		} catch (error) {
			throw new Error(
				`Failed to get audit summary: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		}
	}
}
